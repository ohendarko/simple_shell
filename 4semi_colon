#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include "main.h"
void exec_scomm(char *command)
{
	pid_t pid = fork();

	if (pid < 0)
	{
		perror("Fork failed");
		exit(EXIT_FAILURE);}
	else if (pid == 0)
	{
		// Child process
		char *args[] = {command, NULL};
		if (execvp(command, args) == -1) 
		{
			perror("Execution failed");
			exit(EXIT_FAILURE);
		}
	}
	else
	{// Parent process
		int status;
		waitpid(pid, &status, 0);

		if (WIFEXITED(status))
		{
			printf("Command exited with status %d\n", WEXITSTATUS(status));
		}
	}
}
/**
* exec_comm - core shell function
* @token: argument passed
* Return: nothing
*/
int handle_semicolon(char *token)
{
	char *args[1024]
	int argCount = 0;

	char *token = strtok(input, ";");
	while (token != NULL)
	{
		args[argCount++] = token;
		token = strtok(NULL, ";");
	}
	for (int i = 0; i < argCount; i++)
	{
		exec_scomm(args[i]);
	}
/*
	if (strcmp(token,";") == 0)
	{
		token2 = strtok(input2, ";");
		if (token2 == NULL)
			continue;
		while((token2 = strtok(NULL. ";")) != NULL)
		{
			args[argCount++] = token2;
		}
		for (i = 0; i < sizeof(args); i++)
		{
			for (j = 0; j < sizeof(args[i][j]; j++))
			{
				token3 = strtok(args[i][j], " ");
				while (token3 = strtok(NULL, " ") != NULL)
					args2[arg2Count++] = token3;
				exec_comm(token3);
			}
		}
	}*/
	return (0);
}
