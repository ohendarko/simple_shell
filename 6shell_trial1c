#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <errno.h>
#include "main.h"
void exec_scomm(char *command)
{
         pid_t pid = fork();

         if (pid < 0)
         {
                 perror("Fork failed");
                 exit(EXIT_FAILURE);}
         else if (pid == 0)
         {
                 // Child process
                 char *args[] = {command, NULL};
                 if (execvp(command, args) == -1)
                 {
                         perror("Execution failed");
                         exit(EXIT_FAILURE);
                 }
         }
         else
         {// Parent process
                 int status;
                 waitpid(pid, &status, 0);

                 if (WIFEXITED(status))
                 {
                         printf("Command exited with status %d\n",     WEXITSTATUS(status));
                 }
         }
}

int main()
{
	char input[100];
	char input2[100];
	char *args[1024];
	int argCount = 0;

	while (1)
	{
		printf("$ ");
		fflush(stdout);/*Flush the output to ensure the prompt is displayed */

		if (fgets(input, sizeof(input), stdin) == NULL)
		{
			perror("Error reading input");
			exit(EXIT_FAILURE);
		}
/*Remove the newline character from the input*/
		size_t length = strlen(input);

		if (length > 0 && input[length - 1] == '\n')
		{
			input[length - 1] = '\0';
		}
/*Make a copy of input*/
		strcpy(input2, input);
/*Split the input into command and arguments*/

		char *token = strtok(input, " ");

		if (token == NULL)
		{
			continue;/*Empty input, prompt again*/
		}
/*Check for exit command*/
		if (strcmp(token, "exit") == 0)
			exit(0);

/*implementing the ; command*/
		if (strcmp(token,";") == 0)
		{
			char *token2 = strtok(input2, ";");
			while (token2 != NULL)
			{
				args[argCount++] = token2;
				token2 = strtok(NULL, ";");
			}
			for (int i = 0; i < argCount; i++)
			{
				exec_scomm(args[i]);
			}
		}
		else
		{
			args[0] = token;
			int argCount = 1;

			while((token = strtok(NULL, " ")) != NULL)
				args[argCount++] = token;
		}
		args[argCount] = NULL;
		exec_scomm(args[0]);

	/*	pid_t pid = fork();

		if (pid < 0)
		{
			perror("Fork failed");
			exit(EXIT_FAILURE);
		}
		else if (pid == 0)
		{
			dup2(STDOUT_FILENO, STDOUT_FILENO);
			*Child process*
			if (execvp(args[0], args) < 0)
			{
				perror("Execution failed");
				exit(EXIT_FAILURE);
			}
		}
		else
		{
			*Parent process*
			int status;

			waitpid(pid, &status, 0);
		}*/
	}
	return (0);
}
